TODO:
x - Implement bb service
x - Config file (YAML) and config package to r/w
x - EventRouter to stitch things together
- Logging
x - Break apart and productionize k8s deployment
x - Blob storage
x- DB storage (mysql)
x - Load testing / storage estimates
x - Shrink JS so it's not 9MB?!
x - Fix onprem docker target so it doesn't get run by CI (manual tag?)
x - Support viewing "incomplete" builds
x - Add query support by (user, hostname)
   - make sure this is disabled in cloud
- Figure out how to encode a token in the username / password
   - If set, request is authenticated


// SimpleSearcher Design:
// Some options:
//  - We configure a new database handle inside of simple searcher. Seems dumb but it would work.
//  - We pass in the interfaces.Database object and expose a Search method on it.
//     - but then why do we need the simple searcher interface at all?
//  - We pass in the raw Database struct and use some RawQuery method on it.
//     - Seems like an OK compromise? Need to modify the index so we can search on it with text.
//  - we use a totally different table and index stuff ourselves.
//     - This is probably too complex right now.

- Look into per-target timing, what can we do here?
x - Enable multiple BEP backend support with fwding the RPCs
x - Support Build Event Cache
- LevelDB support (for build cache? as blobstore?)
x - Env Whitelisting / Cleaning -- do it
- Auth
  - support OpenID
- Load testing
x - Devel and prod are broken for some reason, figure out why

// Cache Work
x  - Cache items do not expire
x  - Cache items need a separate TTL from BEP items
x  - A Cache API would make sense
x  - Cache items are too large when returned causing a client error
x  - Need to validate action result by ensuring all items are in cache
x  - GRPC Interceptor to log oversize messages and errors
x  - register cache.buildbuddy.io and cache.buildbuddy.dev for cache traffic
x  - LRU in memory cache
 - Link cache variables to build invocation
x  - REMOVE *tmp files if write fails
x  - Allow downloading artifacts from cache

// User Auth Work
 - Add user auth table
 - Lock down BuildBuddy handler so non-logged in users cannot query for other peoples data
 - Validate jwt token passed in http request
 - Support logged in RPCs for cache data too


// Monitoring etc
 - Support per-invocation cache data
 - Add statusz page for cache hit rate etc


// User / Tables / Database design
 - Problem:
   - Gorm is confusing / has a bad API
   - Gorm makes it too easy to make non-backwards compatible changes
   - Auto-update: what is it even doing? Does it work? What happens when it fails?

 - Solution:
   - Don't expose Gorm directly
   - Limit Gorm to very simple things that can be replaced if necessary
   - Prefer easily auditable queries, not autogenerated ones (Execute / Scan)
   - Store protos, not gorm structs?
 

Architecture and Design:
  - There are ~3~ basic tiers to the backend server:
    - Backend: Generally this is adapter code responsible for talking to
      various backend services or databases. Examples of backend code are:
        - the database adapter
	- the blobstore API client
	- the cache API client
      Backend code must be thread-safe and should generally be stateless.
    - Library: this is code that unifies functionality around commonly
      shared objects, and generally calls backend code to effect state changes.
      Examples of library code are:
        - user code responsible for reading a user object for every request
	- invocation lib code responsible for buffering an invocation before
	  writing to a backend blobstore
      Library code should be thread safe and generally stateless.
    - Handler: This is code that implements an RPC/HTTP handler directly and
      is not useful across multiple handlers (otherwise it would be a library).
      Examples of handler code are:
        - The GetInvocation functionality of the buildbuddy_handler.
	- The bytestream URL file handling functionality in buildbuddy_handler
	- Most of the logic in remote_cache that implements the remote_cache
	  api and then calls into the cache backend to store data.	  
  - There are other types of code too, but they are rare. One example is async
    code that handles stuff like cleanup of expired data. This is most similar
    to a handler, but it's not called externally.
  - We use an environment object to pass around pointers to all of the
    configured backends. This makes it less cumbersome for a handler to accept
    a cache, blobstore, and db backend as well as configuration without having
    to take 4-5+ parameters in its initialization function.
  - We do not assume sticky-session hashing for requests, so all state must be
    kept in the database or other shared storage medium.


Open Source Read Invocation Flow
 - App calls GetInvocation, token is unset
 - Auth handler sets null-user on request context
 - BBHandler calls LookupInvocation with user=nulluser
   - Either something is returned or nothing is returned

 - App calls GetInvocation, token is **set**
 - Auth handler sets null-user on request context
     - because we don't do auth in open source version rn
 - BBHandler calls LookupInvocation with user=nulluser
   - Either something is returned or nothing is returned

Enterprise Read Invocation Flow
 - App calls GetInvocation, token is unset
  - Auth handler sets null-user on request context
 - BBHandler calls LookupInvocation with user=nulluser
   - Either something is returned or nothing is returned

Enterprise Read Invocation Flow
 - App calls GetInvocation, token is **set*
  - Auth handler sets real user on request context
 - BBHandler calls LookupInvocation with user=real user
   - Either something is returned or nothing is returned

Query Support for history?
 - Add an interface for this?